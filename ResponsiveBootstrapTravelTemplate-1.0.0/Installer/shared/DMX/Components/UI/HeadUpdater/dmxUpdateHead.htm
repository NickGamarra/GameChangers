<!-- MENU-LOCATION=NONE -->
<!-- fileVersion = "1.0.16"; -->
<html>
<head>
<title>DMXzone Head Updater</title>
<!--

Command Arguments:

  1. assets -Array of asset paths. 
    - If a given path starts with "!", it is marked as shared and will not be removed on cleanup.
    - If the path is absolute or http, it will remain as is.
    - If the path is siteRoot-relative path (starting with slash), it will be rewritten to be a document-relative.
  2. remove - boolean value indicating if the command should remove these assets or add/update them. Defaults to false.
  3. dontHandleSelection - If true, the selection will not be saved and restored (can be useful somethimes)
  4. checkOnly - can be used to check if the head is up to date, without modifying anything.
                 If this argument is set, than dontHandleSelection arguments is ignored,

Return Value:

  Stores a boolean value at MM.dmxUpdateHeadReturnValue, indicating:

  if checkOnly then the MM.dmxUpdateHeadReturnValue (= NEED CHANGE?) is:
                 - true (UP_TO_DATE) : head is up to date
                 - false (NOT_UP_TO_DATE) : head needs to be updated

	if !checkOnly then the MM.dmxUpdateHeadReturnValue (= EDITED?) is:
                 - true  : head was changed (CHANGED)
                 - false : head was not edited (NOT CHANGED)
  
EXAMPLE:

  dw.runCommand(
    'dmxUpdateHead', 
    [
      "/dmx/widgets/Spinner/style/spinner.css",
      "!/ScriptLibrary/jquery-latest.pack.js",
      "[if lt IE 7]/Styles/IE7.js",             //Browser Conditional include
      "/dmx/widgets/Spinner/spinner.js"
    ]
  );

  if (MM.dmxUpdateHeadReturnValue) // head was changed
  {
    // do somethig...
    delete MM.dmxUpdateHeadReturnValue;
  }

NOTE: To enable debugging messages execute "MM.debugUpdateHead = true;"
      (and "MM.debugUpdateHead = false;" or restart DW to disable them)

HISTORY:
  Version 1.0.5 (George) - 17 feb 2010:
    * fixed when HEAD has dynamic code in it to still be used
    * do not include type="javascript" for XHTML compatibility
    
  Version 1.0.4 (George) - 08 feb 2010:
    * fixed reporting changed to lightbox when checkonly are done and only cleanup is done

  Version 1.0.3 (George) - 26 jan 2010:
    * Support for Server Side Includes
    * support for conditional includes
  
  Version 1.0.6 (Vlad) - 10 mar 2010:
    * Fixed wrong behavior, when used with checkOnly = true option.
    * Added basic debug (logging) logic (to be continued)
  
  Version 1.0.7 (Vlad) - 06 apr 2010:
    * Just an attempt for cleaner code and small bugfixes

  Version 1.0.8 (George) - 13 june 2010:
    * does not use editable regions when used on the main template
    * always insert before the editable head in templates
    * in pages based on templates - use the full head to see if the include is not already there
    * do not give head needs to be updated when checking to remove shared files
    * extended debugging

	Version 1.0.9 (George) - 14 july 2010:    
		* fixed stupid DW8 error due to calling head.ownerDocument.URL which does not exists in DW8

	Version 1.0.10 (George) - 23 august 2010:    
		* add support for case sensitive path, now the useBrokenAssetNodeByPath also checks if paths are case sensitive and use them

	Version 1.0.11 (George) - 28 March 2011:
		* added much more reliable site root detection as well support for site or doc relative links! According to the DW site setting.
		* check if we are not in JS files as opening our extensions JS files will cause them to get updated!
	
	
	Version 1.0.12 (George) - 11 April 2011:	
		* recognizing jquery includes now and also their versions, so all extra jquery includes are stripped and only the latest one is left on top
		
	Version 1.0.13 (George) - 30 May 2011:			
	  * make include paths also unique not only the basename
	  * skip adding includes to CSS files also
	  
	Version 1.0.14 (George) - 23 June 2011:			
		* recognize external google js files and link them

	Version 1.0.15 (George) - 7 July 2011:			
		* ignore url quoery string for include recognition

	Version 1.0.16 (George) - 26 July 2011:			
		* fixed include of full urls and to relative conversion as well site root relative
	  
-->
<script type="text/javascript">
var ASSETS              = [];    // Array of paths
var REMOVE              = false; // true = remove, false = add/update
var NO_SEL              = false; // true = don't restore selection
var CHECK_ONLY          = false;
var DMX_CURRENT_SEL     = null;
var REUSE_BROKEN_PATHS  = true;
var REPARE_BROKEN_PATHS = true;
var REMOVE_DUBLICATES   = true;
var DEBUG_MODE          = false;
var DEBUG_LOG           = [];
var USE_SITE_RELATIVE   = false; // To make links site root relative or doc relative (is DW site setting)


function canAcceptCommand()
{
  var dom = dw.getDocumentDOM();
  
  // skip extension files :-)
  if (!dom || !dom.URL || (dom && dom.URL.indexOf(dw.getConfigurationPath()) === 0)) 
  {
    return false;
  }
  
  if (!(/(html|xml)/).test(dom.getParseMode() || "")) 
  {
    return false;
  }
  
  return true;
}

function isDOMRequired() 
{
  return true;
}

function receiveArguments() 
{
  // reset those
  ASSETS          = [];
  REMOVE          = false; // true = remove, false = add/update
  NO_SEL          = false; // true = don't restore selection
  CHECK_ONLY      = false;
  DMX_CURRENT_SEL = null;
  DEBUG_MODE      = !!MM.debugUpdateHead;
  DEBUG_LOG       = DEBUG_MODE ? [] : null;
  
  log("receiveArguments.arguments", Array.prototype.slice.call(arguments, 0));
  
  if (arguments[0]) 
  {
    ASSETS = isArray(arguments[0]) ? arguments[0] : [arguments[0]];
  }
  if (arguments.length > 1) 
  {
    REMOVE = !!arguments[1];
  }
  if (arguments.length > 2) 
  {
    NO_SEL = !!arguments[2];
  }
  if (arguments.length > 3) 
  {
    CHECK_ONLY = !!arguments[3];
  }
  
  //alert(
  //  "ASSETS = " + ASSETS + "\n" + 
  //  "REMOVE = " + REMOVE + "\n" + 
  //  "NO_SEL = " + NO_SEL + "\n"
  //)
}

function doit() 
{
  if (ASSETS.length > 0) 
  {
    MM.dmxUpdateHeadReturnValue = updateHead(ASSETS, REMOVE, NO_SEL, CHECK_ONLY);
  }
  
  if (DEBUG_MODE) 
  {
  	if (CHECK_ONLY) {
    	log("Command return value", MM.dmxUpdateHeadReturnValue + ' : NEEDS UPDATE -> ' + ( MM.dmxUpdateHeadReturnValue ? ' UP_TO_DATE: head is up to date' : ' NOT_UP_TO_DATE : head needs to be updated'));
    } else {
    	log("Command return value", MM.dmxUpdateHeadReturnValue + ' : EDITED -> ' + ( MM.dmxUpdateHeadReturnValue ? ' CHANGED: head was changed' : ' NOT CHANGED : head was not edited'));
    }
    var msg = "", o;
    for ( var i = 0; i < DEBUG_LOG.length; i++ ) {
      o = DEBUG_LOG[i].data;
      msg += "\n[" + i + "]" + DEBUG_LOG[i].label + ": " + (o && typeof o == "object" ? prettyPrint(o, "\t") : o);
    }
    msg += '\n\nREMOVE :\t' + REMOVE + '\n' +
    			'NO_SEL :\t'+ NO_SEL + '\n' + 
    			'CHECK_ONLY :\t' + CHECK_ONLY;
    alert("DEBUG LOG\n-----------------------------------------------\n" + msg);
  }
  
  DEBUG_LOG = null;
  ASSETS = null;
}

function nodeIndex(parentNode, x)
{
  var index = -1;
  if (parentNode.childNodes)
  {
    for (var i = 0; i < parentNode.childNodes.length; i++)
    {
      if (parentNode.childNodes[i] === x)
      {
        index = i;
        break;
      }
    }
  }
  return index;
}

function getAttributeNameForPath(path)
{
  return (/^js\b/i).test(getFileExtension(path)) ? "src" : "href";
}

function getHTMLForPath(path)
{
  path = path.replace(/^\!/, "");
  var condMatch = path.match(/^\[([^\]]*)\]/);
  var condStr = '';
  if (condMatch && condMatch.length > 1) {
    condStr = condMatch[1];
    path = path.replace(/^\[[^\]]*\]/, "");
  }
  var ext = getFileExtension(path);
  var src = siteRelativeToFileRelative(path);
  var theHtml = (/^js\b/i).test(ext) 
  ? '<scr' + 'ipt type="text/javascr' + 'ipt" src="' + src + '"></scr' + 'ipt>' 
  : '<link rel="stylesheet" type="text/css" href="' + src + '" />';
  if (condStr != '') theHtml = '<!--[' + condStr + ']>' + theHtml + '<![endif]-->';
  return theHtml;
}

function getAssetNodeByPath(head, path)
{
  path = path.replace(/^\!/, "").replace(/^\[[^\]]*\]/, "");
  var ext  = getFileExtension(path);
  var src  = siteRelativeToFileRelative(path);
  var attr = getAttributeNameForPath(path);
  var currentSrc = "", i;
  
  if (!head) log("getAssetNodeByPath", "HEAD is NULL");
  // search for exact match
  for (i = 0; i < head.childNodes.length; i++) 
  {
    //alert('check ' + head.childNodes[i].nodeType + ', ' + (head.childNodes[i].nodeType == 8 ? head.childNodes[i].data : head.childNodes[i].outerHTML));
    if (head.childNodes[i].nodeType === 1) // element node from temp dom
    {
      currentSrc = head.childNodes[i].getAttribute(attr);
      if (currentSrc) {
    		//alert('search ('+attr+') : ' + currentSrc + ', check with: ' + src);            	
        if (currentSrc === src) {
        	log("getAssetNodeByPath", "Found in HEAD as normal element : " + path);
        	//log("getAssetNodeByPath", head.childNodes[i]);
          return head.childNodes[i];
        }
      }
    } else if (head.childNodes[i].nodeType === 8) // element node from temp dom
    {
      var theCommentNode = head.childNodes[i].data;
      if (theCommentNode && theCommentNode != '' && theCommentNode.substr(0,1) == '[') 
      {
        //alert( 'got conditional: ' + theCommentNode);
        if (theCommentNode.indexOf('"' + src + '"') != -1) 
        {
        	log("getAssetNodeByPath", "Found in HEAD as comment node : " + path);
          return head.childNodes[i];
        }
      }
    }

  }
  log("getAssetNodeByPath", "Didn't found in head : " + path);
  return null;
}

function useBrokenAssetNodeByPath(head, path)
{
  var orgPath = path;
  path = path.replace(/^\!/, "").replace(/^\[[^\]]*\]/, "");
  var ext  = getFileExtension(path);
  var src  = siteRelativeToFileRelative(path);
  var attr = getAttributeNameForPath(path);
  var currentSrc = "", i;
  
  // search for exact match
  
  for (i = 0; i < head.childNodes.length; i++) 
  {
    if (head.childNodes[i].nodeType === 1) // element node from temp dom
    {
      currentSrc = head.childNodes[i].getAttribute(attr);
      if (currentSrc) 
      {
        // same basenames && basepath
        if (basename(currentSrc) == basename(src) && basepath(currentSrc) == basepath(src)) 
        {
          // no http paths
          if (currentSrc.indexOf("http://") !== 0) 
          {
          	//alert('found broken ('+attr+') : ' + currentSrc + ', check with: ' + src + '\npath=' + path + '\nabs_path=' + relativeUrlToAbsoluteURL(path));      
            // Always fix the path if different, if target exists
            if (isFile(relativeUrlToAbsoluteURL(path))) {
            	//alert('compare broken: ' + currentSrc.toLowerCase() +' != '+ src.toLowerCase());
	            if ( currentSrc.toLowerCase() != src.toLowerCase()) 
	            {
	              // change attribute !!!
	              head.childNodes[i].setAttribute(attr, src);
	              return head.childNodes[i];
	            }
	          } else {
	          	return head.childNodes[i];
	          }
          } else { // external just use the other URL
            // change attribute !!!
            head.childNodes[i].setAttribute(attr, src);
          	return head.childNodes[i];
          }
        }
      }
    } 
    
    // Search for js and css inside conditional includes
    else if (head.childNodes[i].nodeType == 8) 
    {
      var data = head.childNodes[i].data;
      if (data && data.charAt(0) == '[') 
      {
        currentSrc = data.match(new RegExp("\\b" + attr + '\\s*=\\s*"([^"]+)"'));
        if (currentSrc && currentSrc[1]) 
        {
          currentSrc = currentSrc[1];
          
          // same basenames
          if (basename(currentSrc) == basename(src)) 
          {
            // no http paths
            if (currentSrc.indexOf("http://") !== 0) 
            {
              // always fix the path, if exists
              if (isFile(relativeUrlToAbsoluteURL(path))) {
	              // change attribute !!!
	              head.childNodes[i].data = getHTMLForPath(orgPath).replace(/^<\!--/,"").replace(/-->$/,"");
	            } else {
	              return head.childNodes[i];
	            }
            }
          }
        }
      }
    }
  }
  
  return null;
}

function isJQueryIncludeFile(fileName) {
	var re = /\/jquery-?(\d\.\d(\.\d)?(\.\d)?|latest)?\.?(min|pack)?\.js$/i;
	return re.test(fileName);
}

function getJQueryFileVersion(fileUrl) {
	var jarr;
	//Check for CDN
	if (fileUrl.indexOf('://') != -1) {
		//Guess the version based on the path
		
		//Google:  http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js		
		jarr = fileUrl.match(/\/jquery\/(\d+\.\d+(\.\d+)?)\/jquery\.?(min|pack)?\.js$/i);
		if (!jarr) {
			// Microsoft:  http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.5.2.min.js
			jarr = fileUrl.match(/\/jQuery\/jquery-(\d+\.\d+(\.\d+)?)\.?(min|pack)?\.js$/);
			if (!jarr) {
				// jQuery CDN:  http://code.jquery.com/jquery-1.5.2.min.js
				jarr = fileUrl.match(/\/jquery-(\d+\.\d+(\.\d+)?)\.?(min|pack)?\.js$/);
			}			
		}
	} else {
		//local file
		if (DWfile.exists(fileUrl)) {
			var jcontents = DWfile.read(fileUrl);
			if (jcontents && jcontents != '') {
				//search in jquery code itself
				jarr = jcontents.match(/jquery\s*:\s*"(\d+\.\d+(\.\d+)?)"/i);
				if (!jarr) {
					// * jQuery JavaScript Library v1.5.2
					jarr = jcontents.match(/\*\s+jQuery\s+JavaScript\s+Library\s+v?(\d+\.\d+(\.\d+)?)/i);
					if (!jarr) {
						// * jQuery 1.2.3 - New Wave Javascript
						jarr = jcontents.match(/\*\s+jQuery\s+(\d+\.\d+(\.\d+)?)\s+-\s+New\s+Wave\s+Javascript/i);
					}
				}
			}
		}
	}
	if (jarr && jarr.length > 1) {
		return jarr[1];				
	}	
	return "1.0.0";
}

function getLatestJQueryIncluded(head) {
  var s = head.getElementsByTagName("SCRIPT"), src, latestUrl = "", jQVersion, latestVersion = "1.0.0";
  for (var i = 0; i < s.length; i++) {
    src = s[i].getAttribute("src");
    if (src && isJQueryIncludeFile(src)) {
    	jQVersion = getJQueryFileVersion(src);
    	if (versionCompare(latestVersion, jQVersion)) {
    		latestVersion = jQVersion;
    		latestUrl = src;
    	}
    }
  }
	return latestUrl;
}

function versionCompare(minimum, current) {
	var minimum = '' + minimum; // Convert number to string
	var current = '' + current;
	var parseVersion = function(version) {
		version = /(\d+)\.?(\d+)?\.?(\d+)?/.exec(version);
		return {
			major: parseInt(version[1]) || 0,
			minor: parseInt(version[2]) || 0,
			patch: parseInt(version[3]) || 0
		}
	};
	minimum = parseVersion(minimum);
	current = parseVersion(current);
	if (minimum.major != current.major)
		return (current.major > minimum.major);
	else {
		if (minimum.minor != current.minor) {
			return (current.minor > minimum.minor);
		} else {
			if (minimum.patch != current.patch) {
				return (current.patch > minimum.patch);
			} else {
				return true;
			}
		}
	}
}

function cleanupScripts(head) 
{
  var cleaned = false;
  if ( REMOVE_DUBLICATES || REPARE_BROKEN_PATHS ) {
  	var latestJQuery = getLatestJQueryIncluded(head);
    var s = head.getElementsByTagName("SCRIPT"), src, absSrc, relSrc, found = {};
    for (var i = 0; i < s.length; i++) 
    {
      src = s[i].getAttribute("src");
      if (src) 
      {
      	// if jquery
      	if (latestJQuery != '' && isJQueryIncludeFile(src)) {
   				absSrc = relativeUrlToAbsoluteURL(latestJQuery);
      		if (!found[absSrc]) { // first one
      			if (src != latestJQuery) { // not the latest
      				s[i].setAttribute("src",latestJQuery); // make it latest
      			}
      		} else { // delete all others
            s[i].outerHTML = "";
            cleaned = true;      			
      		}
        	found[absSrc] = 1;      		
      	} else {
      		//Regular includes
	        absSrc = relativeUrlToAbsoluteURL(src);
	        if (found[absSrc])
	        {
	          if (REMOVE_DUBLICATES)
	          {
	            s[i].outerHTML = "";
	            cleaned = true;
	          }
	        }
	        else
	        {
	          if (REPARE_BROKEN_PATHS)
	          {
	            //do not try to repair absolute paths!
	            if (absSrc.indexOf("file://") !== 0 && absSrc.indexOf("http://") !== 0) 
	            {          
	              relSrc = absoluteToRelativeURL(absSrc);
	              if (relSrc != src) 
	              {
	                s[i].setAttribute("src", relSrc);
	                cleaned = true;
	              }
	            }
	          }
	        }
          found[absSrc] = 1;
	      }
      }
    }
    found = null;
  }
  return cleaned;
}

function cleanupStyles(head) 
{ 
  var cleaned = false;
  if ( REMOVE_DUBLICATES || REPARE_BROKEN_PATHS ) {
    var s = head.getElementsByTagName("LINK"), src, absSrc, relSrc, found = {};
    for (var i = 0; i < s.length; i++) 
    {
      if (!s[i].rel || s[i].rel.toLowerCase() != "stylesheet")
      {
        continue;
      }
      src = s[i].getAttribute("href");
      if (src) 
      {
        absSrc = relativeUrlToAbsoluteURL(src);
        if (found[absSrc])
        {
          if (REMOVE_DUBLICATES) 
          {
            s[i].outerHTML = "";
            cleaned = true;
          }
        }
        else
        {
          if (REPARE_BROKEN_PATHS)
          {
            //do not try to repair absolute paths!
            if (absSrc.indexOf("file://") !== 0 && absSrc.indexOf("http://") !== 0) 
            {                    
              relSrc = absoluteToRelativeURL(absSrc);
              if (relSrc != src) 
              {
                s[i].setAttribute("href", relSrc);
                cleaned = true;
              }
            }
          }
        }
        found[absSrc] = 1;
      }
    }
    found = null;
  }
  return cleaned;  
}

function getIncludeFileDOM(includeFile)
{
  dw.useTranslatedSource(false);
  var theIncludeDom = null;
  if (includeFile && includeFile != '') 
  {
  	var absoluteURL = relativeUrlToAbsoluteURL(includeFile); 
    if (DWfile.exists(absoluteURL))
    {
      theIncludeDom = dw.getDocumentDOM(absoluteURL);
      if (theIncludeDom) 
      {
        var head = getHeadNode(theIncludeDom);
        if (!head) return null;
        var ssiFile = isHeadInSSI(head.outerHTML);
        if (ssiFile && ssiFile != '')
        {
          return  getIncludeFileDOM(ssiFile);
        } else return theIncludeDom;
      } else return null;
    } else return null;
  }
  
}

function checkIfArrayContains(arr, elem) {
	if (arr) {
		for (var ae=0; ae < arr.length; ae++) {
			if (arr[ae] == elem) return true;
		}
	}
	return false;
}

function updateHead(assets, remove, dontHandleSelection, checkOnly) 
{
  //MM.Debug.trace();
  checkOnly = !!checkOnly; // convert to boolean
  //alert('updateHead, assets=' + assets + '\n\nsiteRoot='+dw.getSiteRoot()+'\n\nbestSiteRoot='+dmxGetBestSiteRoot());
  
  //Check if current page is in a site
	if (!MM.dmxUpdateHeadIgnorePages) MM.dmxUpdateHeadIgnorePages = [];
  var currentPage = dw.getDocumentPath("document");
	var theSiteRoot = dmxGetBestSiteRoot(currentPage);
	if (currentPage.indexOf(theSiteRoot) == -1) {
		if (!checkIfArrayContains(MM.dmxUpdateHeadIgnorePages, currentPage)) {
			if (confirm('Your page is located outsite a Dreamweaver site definition.\nSome of the used extensions might not work properly.\nWould you like to learn how to define a site in Dreamweaver?')) {
				dreamweaver.browseDocument('http://www.adobe.com/devnet/dreamweaver/articles/first_website_pt1.html');
			}
			MM.dmxUpdateHeadIgnorePages.push(currentPage);
		}		
		return NOT_CHANGED;
	}
	
	//Check if we are not in JS/CSS files as opening our extensions JS files will cause them to get updated!
	var theFileExt = getFileExtension(currentPage);
	if (theFileExt == 'js' || theFileExt == 'css') {
		return NOT_CHANGED;
	}	  
  
  // return codes
  var CHANGED        = true;        // the head was changed
  var UP_TO_DATE     = true;        // checkOnly -> true if head is up to date
  var NOT_UP_TO_DATE = !UP_TO_DATE; // checkOnly -> false if it needs to be updated.
  var NOT_CHANGED    = !CHANGED;    // the head was NOT changed
  var FAILURE        = checkOnly ? NOT_UP_TO_DATE : NOT_CHANGED;
  
  // local vars
  var dom;            // the DOM to inspect/edit 
  var head,fullHead;  // the HEAD to inspect/edit (can be from other DOM)
  var edited = false; // flag (will be togled to true if the head is edited)
  var theIncludeDom;  // SSI DOM (if any)
  var ssiFile;        // SSI URL (if any)
  
  // temp. vars 
  var i, curEl, addToHead = "";
  
  // initialize ----------------------------------------------------------------
  
  // get Document DOM
  dom = dw.getDocumentDOM();
  if ( !dom ) {
    log( "Error", "Cannot get the DOM" );
    return FAILURE;
  }
  
  // synchronize
  if ( !dom.isDesignViewUpdated() ) {
    dom.synchronizeDocument();
    log( "Message", "DW Views were sinchronized" );
  }
  
  //determine site or doc relative

	if (site.getDefaultRelativeTo) {
		//Best way CS3+
		var siteName = site.getSiteForURL(dw.getDocumentPath("document"));
		//alert('site=' + siteName + ' for ' + dw.getDocumentPath("document"));
		USE_SITE_RELATIVE = site.getDefaultRelativeTo(siteName) == "site";
	} else {
	  if (dom.getSiteURLFormatFromDoc) { //Dw8+
			USE_SITE_RELATIVE = (dom.getSiteURLFormatFromDoc() == "site");
		} else {
			USE_SITE_RELATIVE = false; // last default
		}
	}
  
  // get the HEAD
  head = getHeadNode( dom );
  if ( !head ) {
    log( "Error", "Cannot access HEAD node" );
    return FAILURE;
  }
  
  fullHead = getFullHeadNode( dom );
  if ( !fullHead ) {
    log( "Error", "Cannot access full HEAD node" );
    return FAILURE;
  }
  
  // get SSI File
  ssiFile = isHeadInSSI( head.outerHTML ); 
  if ( ssiFile ) {
    log("SSI INCLUDE","Head detected in " + ssiFile);
    // get theIncludeDom
    theIncludeDom = getIncludeFileDOM( ssiFile );
    if (!theIncludeDom) {
      log("Error", "Cannot get the included DOM from " + ssiFile);
      return FAILURE;
    }
    
    // prevent recursion
    if ( theIncludeDom.URL == dom.URL ) {
      log("Error", "SSI recursion detected");
      return FAILURE;
    }
    
    // Reload HEAD from SSI
    head = getHeadNode( theIncludeDom );
    
    if (!head) {
      log("Error", "Cannot get the included HEAD node from " + ssiFile);
      return FAILURE;
    }     

	  fullHead = getFullHeadNode( theIncludeDom );
	  if ( !fullHead ) {
	    log( "Error", "Cannot access included full HEAD node from " + ssiFile );
	    return FAILURE;
	  }
    
  }
  
  // append new nodes if needed
  //  * new login now appends at the end or before one node found
  
  for ( i = 0; i < assets.length; i++) 
  {
    curEl = getAssetNodeByPath(head, assets[i]);
    
    // Do not fix broken paths when checked only
    if (!curEl && !checkOnly && REUSE_BROKEN_PATHS && head.tagName == 'HEAD')
    {    	
      curEl = useBrokenAssetNodeByPath(head, assets[i]);
      if (curEl) {
        log( "Message", "Reusing a broken path for '" + assets[i] + "'" );
        edited = true;
      }
    }
    
    // checkOnly: quickly exit on first case
    // curEl === false && remove === false -> need to add
    // curEl === true  && remove === true  -> need to delete
    // shouldn't do this for shared elements!
    // curEl === true && remove === true && !shared -> need to add
    if ( checkOnly && ( !!curEl === !!remove ) && assets[i].indexOf("!") !== 0 ) {
    	//Check if it is still maybe in the full head
     	var curElinFullHead = getAssetNodeByPath(fullHead, assets[i]);
			if (!curElinFullHead) {
    		log( "Message", "RETURN: NOT_UP_TO_DATE" );
    		return NOT_UP_TO_DATE;
    	}
    }
    
    log("updateHead edited", edited);
    if ( curEl ) // node was found
    {
      // If cleanup is requested and if the extension code does not define 
      // this asset as shared while openning the command
      // Don't remove if in Include file
      if (remove && assets[i].indexOf("!") !== 0 && !theIncludeDom )
      {
        // delete node!
        if (!checkOnly) curEl.outerHTML = "";
        edited = true;
      } 
      else
      {
        //Found one node add all non existing previos before it
        if ( addToHead != '' && !checkOnly ) 
        {
          setOuterHTML( curEl, addToHead + getOuterHTML( curEl ) );
          addToHead = '';
          edited = true;
        }
      }
    }
    else // node was not found
    {
    	log("asset was not found!!!",assets[i]);
      if (!remove) // not found and add is requested
      {
      	//Check if it is still maybe in the full head
      	curEl = getAssetNodeByPath(fullHead, assets[i]);
      	if (!curEl) {      		
      		log("asset add to head: ",assets[i]);
        	addToHead += getHTMLForPath(assets[i]) + '\n';
        } else {
        	//Found in full head
        	log("asset found in FULL head!!!: ",assets[i]);
        }
      }
    }
  }
  log("updateHead addToHead", addToHead);
  
  // just report if the head needs to be updated
  if ( checkOnly ) 
  {
    return edited || addToHead !== '' ? NOT_UP_TO_DATE : UP_TO_DATE;
  }
  
  if ( addToHead != '' )
  { 
    //If real head at at the end or not template - else the beginning (above editable)
    if (dom.getIsTemplateDocument()) {
    	// add above editable region in head
    	head.outerHTML = addToHead + head.outerHTML;
    } else {
    	
	    if ( head.tagName == 'HEAD') {
    		log("ADD TO HEAD, regular", addToHead);	    	
	      head.innerHTML += addToHead;
	    } else {
	    	log("ADD TO HEAD, begin inside", addToHead);	    	
	      head.innerHTML = addToHead + head.innerHTML;
	    }
	  }
    edited = true;
  }
  
  // cleanup if needed
  if ( cleanupScripts(dom) || cleanupStyles(dom) ) {
    log( "Message", "HEAD was cleaned up" );
    edited = true;
  }
  log("updateHead, edited", edited);
  if ( edited ) 
  {    
    if (!dontHandleSelection) {
      dmx_saveBodyRelativeSelection();
      log( "Message", "The current selection was saved" );
    }
    
    // if SSI save it
    if ( theIncludeDom ) {
      if (!DWfile.write( theIncludeDom.URL, theIncludeDom.documentElement.outerHTML )) {
        log( "Error", "Could not write HEAD changes to file " + theIncludeDom.URL);
        return FAILURE;
      }
      alert(
        'The include file ' + theIncludeDom.URL + ' has being changed and saved!'
        + '\nPlease make sure you upload it to your live server.'
      );
    }
    
    if ( !dontHandleSelection ) 
    {
      dmx_restoreBodyRelativeSelection();
      log( "Message", "The current selection was restored" );
      if ( !dom.isDesignViewUpdated() ) 
      {
        dom.synchronizeDocument();
        log( "Message", "DW views were sinchronized" );
      }
    }
  }
  
  return edited ? CHANGED : NOT_CHANGED;
}

function setOuterHTML(node, html)
{
  switch (node.nodeType || "")
  {
    case 1: // Node.ELEMENT_NODE
      node.outerHTML = String(html);
    break;
    
    case 9: // Node.DOCUMENT_NODE
      node.documentElement.outerHTML = String(html);
    break;
    
    case 3: // Node.TEXT_NODE
      node.data = String(html);
    break;
    
    case 8: // Node.COMMENT_NODE
      var doc   = node.ownerDocument;
      var range = doc.nodeToOffsets(node);
      var code  = doc.documentElement.outerHTML;
      doc.documentElement.outerHTML = code.substring(0, range[0]) + String(html) + code.substr(range[1]);
      doc.synchronizeDocument();
    break;
    
    default: 
      // ERROR!!! not a node...
    break; 
  }
}

function getOuterHTML(node)
{
  switch (node.nodeType || "")
  {
    case 1: // Node.ELEMENT_NODE
      return node.outerHTML;
      
    case 3: // Node.TEXT_NODE
      return node.data;
      
    case 8: // Node.COMMENT_NODE
      return node.data.charAt(0) == "<" 
        ? node.data // directive
        : "<" + "!--" + node.data + "--" + ">";
      
    case 9: // Node.DOCUMENT_NODE
      return node.documentElement.outerHTML;
      
    default: return ""; // ERROR!!! not a node...
  }
}

// Version 1.01
//  Now working case insensitive for paths
function absoluteToRelativeURL(absURL, docURL, check) 
{
  if (!docURL) docURL = dw.getDocumentDOM().URL;
  
  //docURL = fixAbsolutePath(docURL);
  var newRef, fullURL, index, filePath, docPath;
  if ((!check || DWfile.exists(absURL)) && absURL) {
    newRef = '';
    fullURL = absURL;
    if (docURL && fullURL.indexOf(docURL) === 0) {
      newRef = fullURL.substring(docURL.length); // doc relative, below doc
    }
    else {
      if (docURL) { // doc relative, above doc
        for (index = 0; index < fullURL.length && index < docURL.length; index++) {
          if (fullURL.charAt(index).toLowerCase() != docURL.charAt(index).toLowerCase()) {
            break;
          }
        }
        index = fullURL.substring(0, index).lastIndexOf(File.separator) + 1; // backup to last directory
        filePath = fullURL.substring(index);
        docPath = docURL.substring(index);
        if (docPath && docPath.indexOf('|') == -1) { // image on a separate drive
          for (var j = 0; j < docPath.length; j++) {
            if (docPath.charAt(j) == File.separator) {
              newRef += "../";
            }
          }
          newRef += filePath;
        }
      }
    }
    if (!newRef) {
      newRef = fullURL; // local file ref
    }
  }
  return newRef;
}

function siteRelativeToFileRelative(path) {
	if (path.indexOf('http://') != -1 || path.indexOf('https://') != -1) return path; // return full urls directly
	
  path = path.replace(/^\!/, "").replace(/^\[[^\]]*\]/, "");	
	var docPath = dw.getDocumentPath("document");
	var siteRoot = dmxGetBestSiteRoot(docPath);
  if (path.indexOf('://') == -1) { // is not absolute yet
  	path = relativeUrlToAbsoluteURL( path); 
  }
	//alert('USE_SITE_RELATIVE=' + USE_SITE_RELATIVE + '\nroot=' + siteRoot + '\npath='+path);
	if (USE_SITE_RELATIVE) { //site root relative		
		var dom = dw.getDocumentDOM(); 
		var sitePrefix = dom.getSiteURLPrefixFromDoc();  
		return sitePrefix + path.substring(siteRoot.length);
	} else { // doc relative
	  return absoluteToRelativeURL(path);
	}
}

//Get the best SiteRoot URL based on the doc
function dmxGetBestSiteRoot(fileURL) {
	var siteRoot = '';
	if (site.getSiteRootForURL) { // CS4+
		if (!fileURL) fileURL = dw.getDocumentPath("document");		
	  siteRoot = site.getSiteRootForURL(fileURL);
	  if (siteRoot == '') {
	  	siteRoot = dw.getSiteRoot();
	  } else {	  	
		  siteRoot = MMNotes.filePathToLocalURL(siteRoot);
		}
	} else {
		siteRoot = dw.getSiteRoot();
	}
	return siteRoot.replace(/\/?$/, '');
}

function getFilePathOnly(theURL) {
  var theFilePath = theURL;
  theFilePath = theFilePath.substring(0, theFilePath.lastIndexOf('/')) + '/';
  return theFilePath;
}


function dmx_saveBodyRelativeSelection() 
{
  var dom = dw.getDocumentDOM();
  if (!dom.isDesignViewUpdated()) dom.synchronizeDocument();
  
  var sel = dom.getSelection();
  
  if (sel && sel.length > 1)
  {
    var bodyOffset = dom.nodeToOffsets(dom.body);

    sel[0] = sel[0] - bodyOffset[0];
    sel[1] = sel[1] - bodyOffset[0];
    
    DMX_CURRENT_SEL = sel;
  }  
}

function dmx_restoreBodyRelativeSelection() 
{
  var sel = DMX_CURRENT_SEL;
  DMX_CURRENT_SEL = null;
  
  if (sel)
  {
    var dom = dw.getDocumentDOM();
    var bodyOffset = dom.nodeToOffsets(dom.body);
    
    sel[0] = sel[0] + bodyOffset[0];
    sel[1] = sel[1] + bodyOffset[0];
    
    dom.setSelection(sel[0], sel[1]);
    if (dw.getFocus() == 'textView') {
    	dom.source.setSelection(sel[0], sel[1]);
    }
  }
}

function getFullHeadNode(dom) // return the full HEAD node if exists
{ 
  var theHead = null;  
  if (!dom) return null;
  
  // regular head  
  var allHeads = dom.getElementsByTagName("HEAD");
  if (allHeads && allHeads.length > 0 ) {
  	theHead = allHeads[0];
  }
  return theHead;
}


function getHeadNode(dom) // return the real HEAD node if exists
{ 
  //dw.useTranslatedSource(true);
  //alert('dw.getTranslateServerSideIncludes() = ' + dw.getTranslateServerSideIncludes());
  var theHead = null;  
  if (!dom) return null;
  
  var allRegions = dom.getEditableRegionList();
  if (allRegions && allRegions.length > 0) {
    for (var ri = 0; ri < allRegions.length; ri++) {
      if (allRegions[ri].name == "head") {
        theHead = allRegions[ri];
        break;
      }
    }
  } else {
    // regular head  
    var allHeads = dom.getElementsByTagName("HEAD");
    if (allHeads && allHeads.length > 0 ) {
      log('getHeadNode: number of heads', allHeads.length);
      if (allHeads.length == 1) 
      {
      	var locks = allHeads[0].getElementsByTagName("MM:BeginLock") || [];
      	if (locks.length > 0) {
      		//log('getHeadNode: SINGLE HEAD with LOCKS in it!', allHeads[0].outerHTML);
      	}
        return allHeads[0];
      }
      for (var hi=0; hi < allHeads.length; hi++) {
        //check if there is locked in the head - if not go to next
        var locks = allHeads[hi].getElementsByTagName("MM:BeginLock") || [];
        log('getHeadNode', 'check ' + hi + ' - ' + allHeads[hi].outerHTML + ', locks = ' + locks.length);        
        if (locks.length == 0)
        {
          log('getHeadNode','found not locked head: ' + allHeads[hi].outerHTML);
          return allHeads[hi];
        }
      }
    }    
  }
  
  //In case of NO head return documentElement
  
  if (!theHead) {
  	log('getHeadNode','NO HEAD!');
  	theHead = dom.documentElement;
  }
  
  return theHead;
}

function isHeadInSSI(str) 
{
  //Check for SSI
  log("Check SSI for", str);
  //Try first standard IIS / Apache include
  var ssi_match = str.match(/^\s*<!--\s*#include\s+(file|virtual)\s*=\s*["|']([^"^']*)["|']\s*-->\s*$/i);
  if (ssi_match && ssi_match.length > 1) {
  	log("ASP SSI FOUND!", ssi_match[2]);
    return ssi_match[2];
  } else {
    // try PHP include
    ssi_match = str.match(/^\s*<\?php\s*(include|include_once|require|require_once)\s*\(\s*["|']([^"^']*)["|']\s*\)\s*;\s*\?>\s*$/i);
    if (ssi_match && ssi_match.length > 1) {
    	log("PHP SSI FOUND!", ssi_match[2]);
      return ssi_match[2];
    }
  }
  log("SSI NOT FOUND for ", str);
  return null;
}

function isArray(object) 
{
  return object != null && typeof object == "object" &&
    'splice' in object && 'join' in object;
}

function getFileExtension(f) 
{
	if (f.indexOf('://') != -1 && f.indexOf('/api/js') != -1) { // external google file
		return 'js';
	}
  f = f.replace(/\?.*$/, "");
	var m = f.match(/^.*\.(\w+)$/i);
	return m && m[1] ? m[1] : '';
}

function getFileName(theURL) {
  var theFilePath = theURL;
  if (theFilePath.lastIndexOf('/') != -1)
    theFilePath = theFilePath.substring(theFilePath.lastIndexOf('/')+1,theFilePath.length);
  return theFilePath;
}


function isFile(path) 
{
	if (DWfile.exists(path)) 
  {
    var attr = DWfile.getAttributes(path);
    if (!attr || (attr && (attr.indexOf("D") == -1))) 
    {
      return true;
    }
  }
  return false;
}

function basename(path) {
	if (path.indexOf('?') != -1) {
		path = path.substring(0,path.lastIndexOf('?'));
	}
  if (path.indexOf('/') == -1) {
    return path;
  }
  return path.substr(path.lastIndexOf('/') + 1);
}

function basepath(path) {
	var lastSl = path.lastIndexOf('/');
  if (lastSl == -1) {
    return '';
  }
  var befSl = path.lastIndexOf('/',lastSl-1);
  return path.substring(befSl+1,lastSl);
}

/**
 * Converts any relative path to absolute (file url).
 * For example the following paths are succesfuly recognized as equal:
 *
 *   - dmx/widgets/Lightbox/styles/default/style.css
 *   - dmx///////widgets/Lightbox/styles/default/style.css
 *   - ./dmx/widgets/Lightbox/styles/default/style.css
 *   - ./dmx/../dmx/widgets/Lightbox/styles/default/style.css
 *   - ./dmx/widgets/../../dmx/widgets/Lightbox/styles/default/style.css
 *
 * If too many "../" are used at the begining of the path, traversing stops
 * at the drive root.
 *
 * @param (string) sURL - relative path to be converted to absolute.
 * Special cases for sURL:
 *  ""    -> returns sBaseURL or URL of the current DOM
 *  "/"   -> returns site root                               (no trailing slash)
 *  "."   -> returns current Document URL dirname            (no trailing slash)
 *  "./"  -> returns current Document URL dirname            (no trailing slash)
 *  ".."  -> returns current Document URL parent dirname     (no trailing slash)
 *  "../" -> returns current Document URL parent dirname     (no trailing slash)
 *
 * @param (string) sBaseURL - Base url. If missing - DOM.URL will be used.
 *
 * @return (string) The computed file url
 *
 * REQUIRES DOM!
 */
function relativeUrlToAbsoluteURL(sURL, sBaseURL) 
{
  // ignore absolute paths
  if (sURL.indexOf("file://") === 0) return sURL;
  if (sURL.indexOf("http://") === 0) return sURL;
  
  // return the original in case of error
  var origUrl = sURL;
  
  // sanitize
  sURL = sURL.replace(/^\s+/, '').replace(/\s+$/, '').replace(/^\.$/, './').replace(/^\.\.$/, '../');
  
  // case ""
  if (!sURL) return dw.getDocumentDOM().URL;
  
  // case "/"
  if (sURL == "/") return dmxGetBestSiteRoot();
  
  // sURL starts with "/" -> siteRoot relative
  if (sURL.indexOf("/") === 0) return dmxGetBestSiteRoot() + sURL;
  
  // default relative to current doc base
  if (!sBaseURL) sBaseURL = dw.getDocumentDOM().URL;
  
  // Convert sBaseURL to dir if needed
  if (sBaseURL.lastIndexOf("/") > 0) sBaseURL = sBaseURL.substr(0, sBaseURL.lastIndexOf("/"));
  
  // case "." and "./"
  if (sURL == "./") return sBaseURL;
  
  // case ".." and "../"
  if (sURL == "../") return sBaseURL.substr(0, sBaseURL.lastIndexOf("/"));
  
  // ignore ./ at the beginning
  if (sURL.indexOf("./") === 0) sURL = sURL.substr(2);
  
  // case filename
  if (sURL.indexOf("/") == -1) return sBaseURL + "/" + sURL;
  
  // compute complex paths
  var root  = sBaseURL.replace(/^(file:\/\/\/)(\w[:\|]\/)?.*/i, '$1$2');
  var sTemp = sBaseURL.replace(root, '') + "/" + sURL;
  var parts = sTemp.split("/");
  var i     = 0;
  
  while (i < parts.length) 
  {
    if (i < 0) return origUrl; // in case of error
    
    switch (parts[i].replace(/^\s+$/, '')) 
    {
      case "" : // multiple slashes also filtered here
      case ".":
        parts.splice(i, 1);
        i--;
      break;
      case "..":
        parts.splice(i-1, 2);
        i -= 2;
      break;
    }
    i++;
  }
  
  sTemp = root + parts.join('/');
  
  return sTemp.replace(/\/$/, '');
}

// The functions below are used for debuging only! =============================
function quoteString(str, useSingleQuotes) {
  var _escapeable;
  var quot = useSingleQuotes ? "'" : '"';
  var _meta = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '\\': '\\\\'
  };
	
  if (useSingleQuotes) {
    _meta["'"] = "\\'";
    _escapeable = /['\\\x00-\x1f\x7f-\x9f]/g;
  } else {
    _meta['"'] = '\\"';
    _escapeable = /["\\\x00-\x1f\x7f-\x9f]/g;
  }
	
  function doQuote(str) {
    if (str.match(_escapeable)) {
      return quot + str.replace(_escapeable, function(a) {
        var c = _meta[a];
        if (typeof c === 'string') return c;
        c = a.charCodeAt();
        return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
      }) + quot;
    }
    return quot + str + quot;
  }
  
  return doQuote(str);
}

function prettyPrint(obj, indentArg, useSingleQuotes) {
  
  var _indentString = "";
  var _indentCount  = 0;
  var _indent       = 0;
  
  if (typeof indentArg == "string") {
    _indentString = indentArg;
    _indentCount  = 1;
  } else if (!isNaN(indentArg)) {
    _indentCount  = parseInt(indentArg, 10);
    _indentString = " ";
  }
  
  function getIndentString() {
    var str = "";
    for (var i = 0; i < _indentCount*_indent; i++) {
      str += _indentString;
    }
    return str;
  }
  
  function loop(o) {
  	if (o === null) return "NULL";
  	//if (o.outerHTML !== null) return o.outerHTML;
    var tmp = [], 
        current = "",
        
        // note that checking instanceof or constructor will fail
        // the object is from other orign (frame)
        inArray = o instanceof Array || typeof o.push == "function";
        
    _indent++;
    for (var x in o) {
      current = getIndentString();
      if (!inArray) {
        current += quoteString(x, useSingleQuotes) + ': ';  
      }
      if (o[x] && typeof o[x] == 'object') {
        current += loop(o[x]);  
      } else if (typeof o[x] == 'string') {
        current += quoteString(o[x], useSingleQuotes);
      } else {
        current += String(o[x]);
      }
      tmp.push(current);
    }
    _indent--;
    tmp = tmp.join(',\n');
    
    tmp = inArray
      ? tmp ? '[\n' + tmp + '\n' + getIndentString() + ']' : "[]"
      : tmp ? '{\n' + tmp + '\n' + getIndentString() + '}' : "{}";
      
    return tmp;
  }
  
  return loop(obj);
}

function trim(str) {
  return trimL(trimR(str));
}

function trimL(str) {
  return str.replace(/^\s*/, "");
}

function trimR(str) {
  return str.replace(/\s*$/, "");
}

function throwError(msg) {
  throw new dw.getDocumentDOM().parentWindow.Error("\n\n" + msg);
}

function log(label, x) {
  if (DEBUG_MODE) DEBUG_LOG.push({
    label: label || "message",
    data : x
  });
}
</script>
</head>
<body onload="doit()">
</body>
</html>
